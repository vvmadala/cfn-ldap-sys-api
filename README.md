# API Template

API Templates act as foundations for developers to start building APIs. They need not worry about adding dependencies and configure autodiscovery as all is handled by the template. The template utilizes the following,


1. **Error Handler Plugin**: This is a common error handler that is fully customizable and is used by the template to handle errors. In case of an error the On Error Propgate is used which sends the information to the error handler which then handles the error, maps to the error object and prints it. This is present at https://anypoint.mulesoft.com/exchange/bd3e00c2-11e3-43c7-9437-c06466696ab7/common-error-handler/ and is added as a dependency to this template. 
2. **Mule Secure Properties**: Uses the Mule Secure Properties connector so that encrypted property values can be used.
3. **Common Modules Library**: This is a utility library that has basic implementation for entry,exit logging and healthcheck. This is present at https://anypoint.mulesoft.com/exchange/bd3e00c2-11e3-43c7-9437-c06466696ab7/common-modules-library/ and is added as a dependency to this template.
4. **JSON Logger**: This is used for Logging in the API and is custom plugin. This is present at https://anypoint.mulesoft.com/exchange/bd3e00c2-11e3-43c7-9437-c06466696ab7/json-logger/ and is added as a dependency to this template.

## Template Features

1. **Logging** - Uses the Common Modules Library to take care of logging
2. **Error Handling** - Uses the Error Handler Plugin to conduct error handling
3. **API Autodiscovery** - Is preconfigured with API Autodiscovery and only the API ID needs to be provided.
4. **Preconfigured APIKIT Router** - Uses the APIKit router which has been configured with the necessary information
5. **End to End Transaction Handling**
6. **Secure and Insecure Property Handling**
7. **MUnit Tests **-** **Provides a sample MUnit test to show how tests can be written for each flow

## Deploying to Exchange

Download the API Template from the source control management system and import it into Studio. Make changes to your application and save. 

Now right click on the application name and click **Anypoint Platform > Publish to Exchange**.

Choose the type as Template and click OK. 

This will publish the updated API Template to Anypoint Exchange.

## Using the API Template

- Open Anypoint Studio and click **File > New > Project from Template**. 

- Click on the template that you published

- Click on Open and the template will open in **Anypoint Studio**.

- Right click on the project name under Package explorer and rename it to **your-application-name-type-api-impl**. **your-application-name-type-api** is the name of your your API Specification. When creating your API Specification in Design Center please name your specification as **your-application-name-type-api. **Here type is **sys**, **proc** or **exp **for system, process and experience APIs. For example if the API Specification in Design Center is named **my-awesome-sys-api**, then the project in Studio will be named **my-awesome-sys-api-impl**
- Open the POM file and change the value of the **groupId** element to the Organization ID of your Anypoint Organization. Your Org Admin can provide you with this value
- In the POM file at line 6, change the value of the **artifactId **element to the name **your-application-name-impl** defined above. Also change the value of the **version** element to **1.0.0 **if not already at **1.0.0**
- In the POM file and line 10, change the value of the **name **element to **your-application-name-type-api-impl**. Here type is **sys**, **proc** or **exp **for system, process and experience APIs.
- Save the POM file
- In the **log4j2.xml** file under **src/main/resources**, search for **api-template** and replace all occurences of it with **your-application-name-type-api-impl**. Here type is **sys**, **proc** or **exp **for system, process and experience APIs.
- To develop your application, you first need to import the RAML for the API Specification for which you need to write the implementation for. To do that right click on the application in **Package Explorer **and click on **Manage Dependencies-> Manage APIs**. 

- Choose the right Business Group from the drop down and then choose the API Definition for which you are creating the implementation for and click OK. When prompted again, click Yes
- This will download the **RAML** from **Design Center** into **Studio **and a file will be created automatically under **src/main/mule** with the name of API definition and with the** .xml **prefix. For example if the name of the API Definition was **my-awesome-system-api**, then the generated file under **src/main/mule** will be **my-awesome-system-api.xml**. This file has the scaffolding generated by the APIKit.
- Once the scaffoling is successful, rename the file to **main.xml**
- Open this file remove the flows named  **api-console**
- Next click on **Global Elements** and move the **Global Element** for the **Router** to **global.xml**. Once moved save both the files.
- The **template-main.xml **file under **src/main/mule** models a few sample flows which are based on the API Definition that is used by the API Template. These flows are to only be used for understanding the template but when you have added your own API definition, please delete the file and also the its corresponding api dependency from pom.xml. 
- Once you delete the above file and its flows, you will see errors appear in **src/test/munit/mule-api-template-test-suite.xml** file. These errors occurs as these Unit tests used the flows that we just deleted. Even though you see errors, you can ignore them for now as they will not hamper the Run of the API. However, once you build you complete API specification, you can use the Unit tests under this file as a reference to write the Unit Tests for you application. Once you have wriiten the Unit tests for your application you can delete the file **template-example-api-impl-test-suite.xml **under **src/test/munit**.
- The file impl.xml is the configuration file where you would be writing your API Implementation. This file will have sub flows which will be called from **main.xml**. 
- impl.xml file has some templates subflows that can be deleted. 
- In the flows generated in **main.xml **add a Flow Reference module. This will call the sub flows created in **impl.xml file** which has the actual implementations.
- For all the JSON Loggers that you add in the implementations, ensure that under the Advanced Tab, the **Correlation id ** is set to  **vars.'x-root-correlation-id'**
------

## MUnit Tests

The API template comes pre-confgured with a basic MUnit test that lets you test your application.  

The tests provided above are just for reference and to show how Unit tests can be written. It is advisable to write tests for your application by using the samples as a reference. Once you have written your tests, delete the **mule-api-template-test-suite.xml** file

In order to configure the run of MUnit tests, open your pom.xml and search for **munit-maven-plugin**

The plugin has been configured to pass any properties that are needed for running the tests and also has information what files can be ignored when running the MUnit tests. If you need to pass any additional properties provide them as elements. You can also choose to skip flows or XML files from not being executed when running the MUnit Tests.

The current minimum coverage is set to 50% which means that for the application to be built correctly the unit tests should run and cover at least 50% of the available flows and XML files.

```
<plugin>
   <groupId>com.mulesoft.munit.tools</groupId>
   <artifactId>munit-maven-plugin</artifactId>
   <version>${munit.version}</version>
     <executions>
        <execution>
           <id>test</id>
           <phase>test</phase>
           <goals>
              <goal>test</goal>
              <goal>coverage-report</goal>
           </goals>
        </execution>
     </executions>
     <configuration>
         <argLines>
             <argLine>-Dmule.env=dev</argLine>
             <argLine>-Dmule.key=your-key</argLine>
             <argLine>-Dhttp.port=8081</argLine>
         </argLines>
     <coverage>
        <runCoverage>true</runCoverage>
        <failBuild>true</failBuild>
        <formats>
           <format>html</format>
        </formats>
        <requiredApplicationCoverage>50</requiredApplicationCoverage>
        <ignoreFlows>
            <ignoreFlow>api-template-api-console</ignoreFlow>
        </ignoreFlows>
        <ignoreFiles>
            <ignoreFile>global.xml</ignoreFile>
            <ignoreFile>soft-error-handler-flow.xml</ignoreFile>
        </ignoreFiles>
     </coverage>
     </configuration>
</plugin>
```

------

------

## Handling Configurations

Every Mule application can have 3 types of configurations, **properties** , **keystores **and **truststores**. Properties are used to pass static and dynamic values to the code and keystores and truststores are used to enable mutual SSL for applications.

### Properties

Properties can either be **static** or **dynamic**.

##### Static Properties

Static properties are constants that do not change when an application is promoted from one environment to other. They remain static at all times. Such kind of properties can be defined in the **config/common.yaml** file in the API Template. This file is present under **src/main/resources**. The syntax to read a static property is **${prop.name}**

##### Dynamic Properties

The properties that change between environments when an application is promoted from one to the other are called dynamic properties. We can further divide dynamic properties into **Secure** and **Insecure** properties

###### Secure Dynamic Properties

These properties are generally credentials or secrets which need to hidden from the user. The API Template supports having such properties configured in the property files named **env-prefix.yaml** where env-prefix can be **dev**, **test**, **stg** and **prod**. The properties stored in these files are stored in an encrypted manner and can be accessed by the application as **${secure::prop.name}**

###### Encrypting Properties

Secure Properties need to be added in an encrypted fashion. The values can be encrypted by running the following command in a command prompt

```
java -jar secure-properties-tool.jar <method> <operation> <algorithm> <mode> <key> <value>
```

- **method** is hardcoded to string
- **operation** takes the values encrypt or decrypt
- **algorithm** is the encryption algorithm
- **mode** is the encryption mode
- **key** is the encryption/decryption key
- **value** is the plain text value that needs to encrypted or the encrypted value that needs to be decrypted

Once the value is encrypted it can be added as 

```
prop.name=![encryptedValue]
```

where **prop.name** is the name of your encrypted property

##### Insecure Dynamic Properties

These properties do not need to hidden from a user but change from one environment to the other. These properties are defined in property files named **${env}.yaml** where **env** can have values **dev**, **test**, **stg** and **prod**. The syntax to read these are **${insecure-dynamic-prop.name}**

### Keystores

Keystores are used to enable TLS access to applications. To use keystores store the keystores under **src/main/resources/keystore**

------

## Editing the mule-artifact.json

Under the root folder of the project open the mule-artifact.json 

Perform the following updates in this file,

- **configs**: Add the names of the all the XML files under src/main/mule as an array of strings
- **secureProperties**: When an application is deployed to CloudHub some properties need to be set as hidden and not encrypted. For example the encryption/decryption key that is used to decrypt the encrypted values should not be stored as plain text and should be hidden from plain sight. You can define that property name here. The mule.key property which is used to store the key is already defined here. If there are any other properties that need to be safely hidden provide them here as comma separated values
- **redeploymentEnabled**: Leave it set to true
- **name**: This is the name of your project which is your-application-name-impl
- **minMuleVersion**: The runtime version for which this application is created for.
- **requiredProduct**: Leave it set to MULE\_EE
- **classLoaderModelLoaderDescriptor**: Leave it as is
- **bundleDescriptorLoader**: Leave it as is

------

## Logging

The API Template shows an example for doing logging and uses the JSON Logger which is custom extension that automatically formats the logs to a JSON Object. A reference is provided that explains what and when to log. 

